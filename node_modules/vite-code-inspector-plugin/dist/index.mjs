var P = Object.defineProperty, d = Object.defineProperties;
var W = Object.getOwnPropertyDescriptors;
var y = Object.getOwnPropertySymbols;
var T = Object.prototype.hasOwnProperty, j = Object.prototype.propertyIsEnumerable;
var x = (e, r, l) => r in e ? P(e, r, { enumerable: !0, configurable: !0, writable: !0, value: l }) : e[r] = l, h = (e, r) => {
  for (var l in r || (r = {}))
    T.call(r, l) && x(e, l, r[l]);
  if (y)
    for (var l of y(r))
      j.call(r, l) && x(e, l, r[l]);
  return e;
}, V = (e, r) => d(e, W(r));
var i = (e, r, l) => new Promise((t, s) => {
  var f = (n) => {
    try {
      u(l.next(n));
    } catch (c) {
      s(c);
    }
  }, a = (n) => {
    try {
      u(l.throw(n));
    } catch (c) {
      s(c);
    }
  }, u = (n) => n.done ? t(n.value) : Promise.resolve(n.value).then(f, a);
  u((l = l.apply(e, r)).next());
});
import { startServer as J, ViteVirtualModule_EliminateVueWarning as m, ViteVirtualModule_Client as g, getEliminateVueWarningCode as _, getClientInjectCode as w, getCodeWithWebComponent as E, normalizePath as S, isJsTypeFile as $, transformCode as v } from "code-inspector-core";
const I = "vite-code-inspector-plugin", L = ["isJsx", "isTsx", "lang.jsx", "lang.tsx"];
function F(e) {
  const r = {
    port: 0,
    entry: "",
    nextJsEntry: "",
    ssrEntry: ""
  };
  return V(h({
    name: I
  }, e.enforcePre === !1 ? {} : { enforce: "pre" }), {
    apply(t, { command: s }) {
      if (e != null && e.close)
        return !1;
      let f;
      return typeof (e == null ? void 0 : e.dev) == "function" ? f = e == null ? void 0 : e.dev() : f = e == null ? void 0 : e.dev, f === !1 ? !1 : !!f || s === "serve";
    },
    resolveId(t) {
      return i(this, null, function* () {
        return r.port || (yield J(e, r)), t === m ? "\0".concat(m) : t === g ? "\0".concat(g) : null;
      });
    },
    load(t) {
      return t === "\0".concat(m) ? _() : t === "\0".concat(g) ? w(r.port, e) : null;
    },
    transform(t, s) {
      return i(this, null, function* () {
        if (s.match("node_modules"))
          return t;
        t = yield E(e, s, t, r);
        const [f] = s.split("?", 2), a = S(f), u = new URLSearchParams(s);
        if (e != null && e.match && !e.match.test(a))
          return t;
        const { escapeTags: n = [] } = e || {};
        return $(a) || a.endsWith(".vue") && (L.some((C) => u.get(C) !== null) || u.get("lang") === "tsx" || u.get("lang") === "jsx") ? v({
          content: t,
          filePath: a,
          fileType: "jsx",
          escapeTags: n
        }) : a.endsWith(".vue") && u.get("type") !== "style" && u.get("raw") === null ? v({
          content: t,
          filePath: a,
          fileType: "vue",
          escapeTags: n
        }) : a.endsWith(".svelte") ? v({
          content: t,
          filePath: a,
          fileType: "svelte",
          escapeTags: n
        }) : t;
      });
    }
  });
}
export {
  F as ViteCodeInspectorPlugin
};
