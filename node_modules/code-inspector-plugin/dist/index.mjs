var I = Object.defineProperty, $ = Object.defineProperties;
var V = Object.getOwnPropertyDescriptors;
var h = Object.getOwnPropertySymbols;
var j = Object.prototype.hasOwnProperty, k = Object.prototype.propertyIsEnumerable;
var E = (e, t, n) => t in e ? I(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, p = (e, t) => {
  for (var n in t || (t = {}))
    j.call(t, n) && E(e, n, t[n]);
  if (h)
    for (var n of h(t))
      k.call(t, n) && E(e, n, t[n]);
  return e;
}, f = (e, t) => $(e, V(t));
import { ViteCodeInspectorPlugin as T } from "vite-code-inspector-plugin";
import P from "webpack-code-inspector-plugin";
import x from "chalk";
import v from "fs";
import _ from "path";
function C(e) {
  if (e.__esModule)
    return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function o() {
      if (this instanceof o) {
        var s = [null];
        s.push.apply(s, arguments);
        var r = Function.bind.apply(t, s);
        return new r();
      }
      return t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else
    n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(e).forEach(function(o) {
    var s = Object.getOwnPropertyDescriptor(e, o);
    Object.defineProperty(n, o, s.get ? s : {
      enumerable: !0,
      get: function() {
        return e[o];
      }
    });
  }), n;
}
var a = {}, K = {
  get exports() {
    return a;
  },
  set exports(e) {
    a = e;
  }
};
const R = {}, A = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: R
}, Symbol.toStringTag, { value: "Module" })), b = /* @__PURE__ */ C(A), S = "dotenv", Y = "16.3.1", L = "Loads environment variables from .env file", F = "lib/main.js", B = "lib/main.d.ts", M = {
  ".": {
    types: "./lib/main.d.ts",
    require: "./lib/main.js",
    default: "./lib/main.js"
  },
  "./config": "./config.js",
  "./config.js": "./config.js",
  "./lib/env-options": "./lib/env-options.js",
  "./lib/env-options.js": "./lib/env-options.js",
  "./lib/cli-options": "./lib/cli-options.js",
  "./lib/cli-options.js": "./lib/cli-options.js",
  "./package.json": "./package.json"
}, U = {
  "dts-check": "tsc --project tests/types/tsconfig.json",
  lint: "standard",
  "lint-readme": "standard-markdown",
  pretest: "npm run lint && npm run dts-check",
  test: "tap tests/*.js --100 -Rspec",
  prerelease: "npm test",
  release: "standard-version"
}, W = {
  type: "git",
  url: "git://github.com/motdotla/dotenv.git"
}, q = "https://github.com/motdotla/dotenv?sponsor=1", G = [
  "dotenv",
  "env",
  ".env",
  "environment",
  "variables",
  "config",
  "settings"
], J = "README.md", Q = "BSD-2-Clause", z = {
  "@definitelytyped/dtslint": "^0.0.133",
  "@types/node": "^18.11.3",
  decache: "^4.6.1",
  sinon: "^14.0.1",
  standard: "^17.0.0",
  "standard-markdown": "^7.1.0",
  "standard-version": "^9.5.0",
  tap: "^16.3.0",
  tar: "^6.1.11",
  typescript: "^4.8.4"
}, H = {
  node: ">=12"
}, X = {
  fs: !1
}, Z = {
  name: S,
  version: Y,
  description: L,
  main: F,
  types: B,
  exports: M,
  scripts: U,
  repository: W,
  funding: q,
  keywords: G,
  readmeFilename: J,
  license: Q,
  devDependencies: z,
  engines: H,
  browser: X
}, w = v, m = _, ee = b, te = b, ne = Z, y = ne.version, re = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
function oe(e) {
  const t = {};
  let n = e.toString();
  n = n.replace(/\r\n?/mg, "\n");
  let o;
  for (; (o = re.exec(n)) != null; ) {
    const s = o[1];
    let r = o[2] || "";
    r = r.trim();
    const c = r[0];
    r = r.replace(/^(['"`])([\s\S]*)\1$/mg, "$2"), c === '"' && (r = r.replace(/\\n/g, "\n"), r = r.replace(/\\r/g, "\r")), t[s] = r;
  }
  return t;
}
function se(e) {
  const t = O(e), n = i.configDotenv({ path: t });
  if (!n.parsed)
    throw new Error("MISSING_DATA: Cannot parse ".concat(t, " for an unknown reason"));
  const o = D(e).split(","), s = o.length;
  let r;
  for (let c = 0; c < s; c++)
    try {
      const l = o[c].trim(), u = ae(n, l);
      r = i.decrypt(u.ciphertext, u.key);
      break;
    } catch (l) {
      if (c + 1 >= s)
        throw l;
    }
  return i.parse(r);
}
function ce(e) {
  console.log("[dotenv@".concat(y, "][INFO] ").concat(e));
}
function ie(e) {
  console.log("[dotenv@".concat(y, "][WARN] ").concat(e));
}
function g(e) {
  console.log("[dotenv@".concat(y, "][DEBUG] ").concat(e));
}
function D(e) {
  return e && e.DOTENV_KEY && e.DOTENV_KEY.length > 0 ? e.DOTENV_KEY : process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0 ? process.env.DOTENV_KEY : "";
}
function ae(e, t) {
  let n;
  try {
    n = new URL(t);
  } catch (l) {
    throw l.code === "ERR_INVALID_URL" ? new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenv.org/vault/.env.vault?environment=development") : l;
  }
  const o = n.password;
  if (!o)
    throw new Error("INVALID_DOTENV_KEY: Missing key part");
  const s = n.searchParams.get("environment");
  if (!s)
    throw new Error("INVALID_DOTENV_KEY: Missing environment part");
  const r = "DOTENV_VAULT_".concat(s.toUpperCase()), c = e.parsed[r];
  if (!c)
    throw new Error("NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ".concat(r, " in your .env.vault file."));
  return { ciphertext: c, key: o };
}
function O(e) {
  let t = m.resolve(process.cwd(), ".env");
  return e && e.path && e.path.length > 0 && (t = e.path), t.endsWith(".vault") ? t : "".concat(t, ".vault");
}
function le(e) {
  return e[0] === "~" ? m.join(ee.homedir(), e.slice(1)) : e;
}
function ue(e) {
  ce("Loading env from encrypted .env.vault");
  const t = i._parseVault(e);
  let n = process.env;
  return e && e.processEnv != null && (n = e.processEnv), i.populate(n, t, e), { parsed: t };
}
function de(e) {
  let t = m.resolve(process.cwd(), ".env"), n = "utf8";
  const o = !!(e && e.debug);
  e && (e.path != null && (t = le(e.path)), e.encoding != null && (n = e.encoding));
  try {
    const s = i.parse(w.readFileSync(t, { encoding: n }));
    let r = process.env;
    return e && e.processEnv != null && (r = e.processEnv), i.populate(r, s, e), { parsed: s };
  } catch (s) {
    return o && g("Failed to load ".concat(t, " ").concat(s.message)), { error: s };
  }
}
function pe(e) {
  const t = O(e);
  return D(e).length === 0 ? i.configDotenv(e) : w.existsSync(t) ? i._configVault(e) : (ie("You set DOTENV_KEY but you are missing a .env.vault file at ".concat(t, ". Did you forget to build it?")), i.configDotenv(e));
}
function fe(e, t) {
  const n = Buffer.from(t.slice(-64), "hex");
  let o = Buffer.from(e, "base64");
  const s = o.slice(0, 12), r = o.slice(-16);
  o = o.slice(12, -16);
  try {
    const c = te.createDecipheriv("aes-256-gcm", n, s);
    return c.setAuthTag(r), "".concat(c.update(o)).concat(c.final());
  } catch (c) {
    const l = c instanceof RangeError, u = c.message === "Invalid key length", N = c.message === "Unsupported state or unable to authenticate data";
    if (l || u) {
      const d = "INVALID_DOTENV_KEY: It must be 64 characters long (or more)";
      throw new Error(d);
    } else if (N) {
      const d = "DECRYPTION_FAILED: Please check your DOTENV_KEY";
      throw new Error(d);
    } else
      throw console.error("Error: ", c.code), console.error("Error: ", c.message), c;
  }
}
function ve(e, t, n = {}) {
  const o = !!(n && n.debug), s = !!(n && n.override);
  if (typeof t != "object")
    throw new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
  for (const r of Object.keys(t))
    Object.prototype.hasOwnProperty.call(e, r) ? (s === !0 && (e[r] = t[r]), o && g(s === !0 ? '"'.concat(r, '" is already defined and WAS overwritten') : '"'.concat(r, '" is already defined and was NOT overwritten'))) : e[r] = t[r];
}
const i = {
  configDotenv: de,
  _configVault: ue,
  _parseVault: se,
  config: pe,
  decrypt: fe,
  parse: oe,
  populate: ve
};
a.configDotenv = i.configDotenv;
a._configVault = i._configVault;
a._parseVault = i._parseVault;
a.config = i.config;
a.decrypt = i.decrypt;
a.parse = i.parse;
a.populate = i.populate;
K.exports = i;
function ge(e) {
  if (!(e != null && e.bundler)) {
    console.log(
      x.red(
        "Please specify the bundler in the options of code-inspector-plugin."
      )
    );
    return;
  }
  let t = !1;
  if (e.needEnvInspector)
    if (t = !0, process.env.CODE_INSPECTOR === "true")
      t = !1;
    else {
      const o = _.resolve(process.cwd(), ".env.local");
      if (v.existsSync(o)) {
        const s = v.readFileSync(o, "utf-8"), r = a.parse(s || "");
        (r == null ? void 0 : r.CODE_INSPECTOR) === "true" && (t = !1);
      }
    }
  return e.bundler === "webpack" || e.bundler === "rspack" ? new P(f(p({}, e), { close: t })) : T(f(p({}, e), { close: t }));
}
const we = ge;
export {
  ge as CodeInspectorPlugin,
  we as codeInspectorPlugin
};
